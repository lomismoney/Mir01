name: Deploy to Google Cloud

on:
  push:
    branches:
      - master
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deploy (ignore cache)'
        required: false
        default: 'false'
      deploy_target:
        description: 'Deploy target (api/client/both)'
        required: false
        default: 'both'
        type: choice
        options:
          - both
          - api
          - client

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCS_BUCKET: ${{ secrets.GCS_BUCKET }}
  CLOUD_SQL_CONNECTION_NAME: ${{ secrets.CLOUD_SQL_CONNECTION_NAME }}
  API_SERVICE_NAME: inventory-api
  CLIENT_SERVICE_NAME: inventory-client
  REGION: asia-east1

jobs:
  # 檢測變更的檔案和倉庫驗證
  detect-changes:
    name: 'Detect Changes'
    runs-on: ubuntu-latest
    # 🔐 限制只在指定倉庫執行
    if: github.repository == 'lomismoney/Mir01'
    outputs:
      api-changed: ${{ steps.changes.outputs.api }}
      client-changed: ${{ steps.changes.outputs.client }}
      client-needs-deploy: ${{ steps.changes.outputs.client-needs-deploy }}
      force-deploy: ${{ github.event.inputs.force_deploy == 'true' }}
      deploy-target: ${{ github.event.inputs.deploy_target || 'auto' }}
    steps:
      - name: 'Checkout'
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: 'Detect file changes and dependencies'
        id: changes
        run: |
          # 初始化變更檢測變數
          API_CHANGED=false
          CLIENT_CHANGED=false
          
          echo "🔍 檢查倉庫: ${{ github.repository }}"
          echo "✅ 倉庫驗證通過: ${{ github.repository }}"
          
          if [ "${{ github.event.inputs.force_deploy }}" == "true" ]; then
            echo "api=true" >> $GITHUB_OUTPUT
            echo "client=true" >> $GITHUB_OUTPUT
            echo "client-needs-deploy=true" >> $GITHUB_OUTPUT
            echo "🔄 強制部署 - 所有服務將被重新部署"
            exit 0
          fi

          # 🎯 處理手動部署目標
          DEPLOY_TARGET="${{ github.event.inputs.deploy_target || 'auto' }}"
          if [ "$DEPLOY_TARGET" == "api" ]; then
            echo "api=true" >> $GITHUB_OUTPUT
            echo "client=false" >> $GITHUB_OUTPUT
            echo "client-needs-deploy=false" >> $GITHUB_OUTPUT
            echo "🎯 手動指定部署 API only"
            exit 0
          elif [ "$DEPLOY_TARGET" == "client" ]; then
            echo "api=false" >> $GITHUB_OUTPUT
            echo "client=true" >> $GITHUB_OUTPUT
            echo "client-needs-deploy=true" >> $GITHUB_OUTPUT
            echo "🎯 手動指定部署 Client only"
            exit 0
          elif [ "$DEPLOY_TARGET" == "both" ]; then
            echo "api=true" >> $GITHUB_OUTPUT
            echo "client=true" >> $GITHUB_OUTPUT
            echo "client-needs-deploy=true" >> $GITHUB_OUTPUT
            echo "🎯 手動指定部署 Both (API + Client)"
            exit 0
          fi
          
          # 🤖 auto 模式：根據檔案變更智能決定部署目標
          echo "🤖 自動模式：根據檔案變更智能決定部署目標"

          # 🔍 檢測自動推送時的文件變更（處理邊界情況）
          echo "🔍 檢測檔案變更..."
          
          # 檢查是否是初始提交或單一提交的情況
          if ! git rev-parse HEAD~1 >/dev/null 2>&1; then
            echo "⚠️ 偵測到初始提交或單一提交，假設所有檔案都有變更"
            API_CHANGED=true
            CLIENT_CHANGED=true
            echo "📦 初始部署 - API 和 Client 都需要部署"
          else
            # 正常的變更檢測
            if git diff --name-only HEAD~1 HEAD | grep -q "^inventory-api/"; then
              API_CHANGED=true
              echo "📦 檢測到 API 變更"
            else
              echo "✅ API 無變更"
            fi

            if git diff --name-only HEAD~1 HEAD | grep -q "^inventory-client/"; then
              CLIENT_CHANGED=true
              echo "📦 檢測到 Client 變更"
            else
              echo "✅ Client 無變更"
            fi
          fi

          # 🔗 依賴邏輯：如果 API 有變更，Client 也需要重新部署（同步 openapi.yaml）
          CLIENT_NEEDS_DEPLOY=false
          if [ "$API_CHANGED" = true ]; then
            CLIENT_NEEDS_DEPLOY=true
            if [ "$CLIENT_CHANGED" = true ]; then
              echo "🔗 API + Client 都有變更 -> 全面部署"
            else
              echo "🔗 API 變更detected -> Client 需要同步部署 (openapi.yaml 依賴)"
            fi
          elif [ "$CLIENT_CHANGED" = true ]; then
            CLIENT_NEEDS_DEPLOY=true
            echo "🎯 Client 直接變更 -> Client 需要部署"
          fi

          # 輸出結果
          echo "api=$API_CHANGED" >> $GITHUB_OUTPUT
          echo "client=$CLIENT_CHANGED" >> $GITHUB_OUTPUT
          echo "client-needs-deploy=$CLIENT_NEEDS_DEPLOY" >> $GITHUB_OUTPUT
          
          # 總結輸出
          echo ""
          echo "📋 部署決策總結："
          echo "   API 部署: $API_CHANGED"
          echo "   Client 部署: $CLIENT_NEEDS_DEPLOY"
          if [ "$API_CHANGED" = true ] && [ "$CLIENT_CHANGED" = false ]; then
            echo "   原因: API 變更 -> Client 同步 openapi.yaml"
          elif [ "$API_CHANGED" = false ] && [ "$CLIENT_CHANGED" = true ]; then
            echo "   原因: Client 直接變更"
          elif [ "$API_CHANGED" = true ] && [ "$CLIENT_CHANGED" = true ]; then
            echo "   原因: API 和 Client 都有變更"
          elif [ "$API_CHANGED" = false ] && [ "$CLIENT_CHANGED" = false ]; then
            echo "   原因: 無變更 - 可能是手動觸發或 force deploy"
          fi

  deploy-api:
    name: 'Deploy API to Cloud Run'
    runs-on: ubuntu-latest
    needs: detect-changes
    # 🔐 只有當 API 需要部署時才執行
    if: needs.detect-changes.outputs.api-changed == 'true'
    
    permissions:
      contents: 'read'
      id-token: 'write'

    defaults:
      run:
        working-directory: ./inventory-api

    steps:
      - name: 'Checkout'
        uses: actions/checkout@v4

      - name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}
          token_format: 'access_token'

      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v2'

      - name: 'Setup PHP with Composer'
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          extensions: gd, zip, pcntl, bcmath, xml, pdo_sqlite
          coverage: none

      - name: 'Cache Composer dependencies'
        uses: actions/cache@v4
        with:
          path: |
            inventory-api/vendor
            ~/.composer/cache
          key: ${{ runner.os }}-composer-${{ hashFiles('inventory-api/composer.lock') }}
          restore-keys: |
            ${{ runner.os }}-composer-

      - name: 'Install Composer Dependencies (for Scribe only)'
        run: composer install --prefer-dist --no-progress --optimize-autoloader

      - name: 'Cache OpenAPI Generation'
        id: cache-openapi
        uses: actions/cache@v4
        with:
          path: inventory-api/storage/app/scribe/openapi.yaml
          key: ${{ runner.os }}-openapi-${{ hashFiles('inventory-api/app/Http/**/*.php', 'inventory-api/routes/**/*.php') }}
          restore-keys: |
            ${{ runner.os }}-openapi-

      - name: 'Generate OpenAPI Specification'
        if: steps.cache-openapi.outputs.cache-hit != 'true'
        run: |
          echo "APP_ENV=testing" > .env.testing
          echo "APP_KEY=base64:some_random_key_for_testing" >> .env.testing
          echo "DB_CONNECTION=sqlite" >> .env.testing
          echo "DB_DATABASE=database/testing.sqlite" >> .env.testing
          echo "CACHE_STORE=array" >> .env.testing
          echo "QUEUE_CONNECTION=sync" >> .env.testing
          echo "SESSION_DRIVER=array" >> .env.testing
          echo "DB_CACHE_CONNECTION=sqlite" >> .env.testing

          touch database/testing.sqlite
          php artisan migrate:fresh --force --env=testing
          php artisan scribe:generate --verbose --env=testing

      # 🚀 Docker 構建優化 - 使用多層緩存
      - name: 'Set up Docker Buildx'
        uses: docker/setup-buildx-action@v3

      - name: 'Create Artifact Repository (if not exists)'
        run: |
          # 主要映像儲存庫
          gcloud artifacts repositories create ${{ env.API_SERVICE_NAME }}-repo \
            --repository-format=docker \
            --location=${{ env.REGION }} \
            --description="API Docker repository" || echo "✅ Main repo already exists"

      - name: 'Configure Docker for Artifact Registry'
        run: gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev

      - name: 'Build and Push API Docker Image (Super Optimized)'
        uses: docker/build-push-action@v5
        with:
          context: ./inventory-api
          push: true
          tags: ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.API_SERVICE_NAME }}-repo/api:latest
          # 🚀 超級快取策略：GHA + Registry + Inline
          cache-from: |
            type=gha
            type=registry,ref=${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.API_SERVICE_NAME }}-repo/cache
          cache-to: |
            type=gha,mode=max
            type=registry,ref=${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.API_SERVICE_NAME }}-repo/cache,mode=max
          platforms: linux/amd64
          # 🔧 建置優化參數
          build-args: |
            BUILDKIT_INLINE_CACHE=1
          # 🎯 多核心並行建置
          outputs: type=image,compression=gzip,compression-level=6

      - name: 'Deploy API to Cloud Run (固定域名版本)'
        run: |-
          gcloud run deploy ${{ env.API_SERVICE_NAME }} \
            --image=${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.API_SERVICE_NAME }}-repo/api:latest \
            --region=${{ env.REGION }} \
            --platform=managed \
            --allow-unauthenticated \
            --add-cloudsql-instances=${{ env.CLOUD_SQL_CONNECTION_NAME }} \
            --add-volume=name=gcs-storage,type=cloud-storage,bucket=${{ env.GCS_BUCKET }} \
            --add-volume-mount=volume=gcs-storage,mount-path=/mnt/gcs \
            --set-env-vars="APP_ENV=production,APP_NAME=庫存管理系統,APP_DEBUG=false,APP_TIMEZONE=Asia/Taipei,APP_LOCALE=zh_TW,APP_FALLBACK_LOCALE=zh_TW,BCRYPT_ROUNDS=12,APP_MAINTENANCE_DRIVER=file,DB_CONNECTION=mysql,DB_SOCKET=/cloudsql/${{ env.CLOUD_SQL_CONNECTION_NAME }},DB_PORT=3306,DB_DATABASE=lomis_internal,DB_USERNAME=h1431532403240,SESSION_DOMAIN=.lomis.com.tw,SESSION_DRIVER=file,SESSION_LIFETIME=120,SESSION_ENCRYPT=false,SESSION_PATH=/,FILESYSTEM_DISK=gcs,GCS_BUCKET=${{ env.GCS_BUCKET }},GOOGLE_CLOUD_PROJECT_ID=${{ env.PROJECT_ID }},CACHE_STORE=file,QUEUE_CONNECTION=sync,BROADCAST_CONNECTION=log,LOG_CHANNEL=stack,LOG_LEVEL=error,SPATIE_PERMISSION_CACHE_EXPIRATION_TIME=3600,GCS_MOUNT_PATH=/mnt/gcs,FRONTEND_URL=${{ secrets.CLIENT_CUSTOM_DOMAIN_URL }},SANCTUM_STATEFUL_DOMAINS=$(echo '${{ secrets.CLIENT_CUSTOM_DOMAIN_URL }}' | sed 's|https://||' | sed 's|/.*||')" \
            --set-secrets="APP_KEY=LARAVEL_APP_KEY:latest,DB_PASSWORD=LARAVEL_DB_PASSWORD:latest" \
            --timeout=300 \
            --memory=1Gi \
            --cpu=2 \
            --concurrency=80 \
            --min-instances=0 \
            --max-instances=5
        working-directory: . # 此步驟在根目錄執行

      # 註解：動態域名獲取（保留以備將來使用）
      # - name: 'Get Deployed URLs (動態域名 - 已停用)'
      #   id: get_urls
      #   run: |-
      #     # 獲取 API 服務的實際 URL
      #     API_URL=$(gcloud run services describe ${{ env.API_SERVICE_NAME }} --platform=managed --region=${{ env.REGION }} --format='value(status.url)')
      #     echo "API_URL=$API_URL" >> $GITHUB_OUTPUT
      #     
      #     # 嘗試獲取前端服務 URL（如果已存在）
      #     CLIENT_URL=$(gcloud run services describe ${{ env.CLIENT_SERVICE_NAME }} --platform=managed --region=${{ env.REGION }} --format='value(status.url)' 2>/dev/null || echo "")
      #     
      #     if [ -z "$CLIENT_URL" ]; then
      #       # 如果前端還未部署，使用 API URL 的相同模式
      #       CLIENT_BASE=$(echo $API_URL | sed 's/inventory-api/inventory-client/')
      #       echo "CLIENT_URL=$CLIENT_BASE" >> $GITHUB_OUTPUT
      #     else
      #       echo "CLIENT_URL=$CLIENT_URL" >> $GITHUB_OUTPUT
      #     fi
      #     
      #     # 提取域名用於 SANCTUM（只使用前端域名）
      #     CLIENT_DOMAIN=$(echo ${CLIENT_URL:-$CLIENT_BASE} | sed 's|https://||' | sed 's|/.*||')
      #     echo "SANCTUM_DOMAINS=$CLIENT_DOMAIN" >> $GITHUB_OUTPUT
      #     
      #     echo "API URL: $API_URL"
      #     echo "預期的前端 URL: ${CLIENT_URL:-$CLIENT_BASE}"
      #   working-directory: . # 此步驟在根目錄執行

      - name: 'Run Database Migrations'
        run: |-
          gcloud run jobs create ${{ env.API_SERVICE_NAME }}-migrate \
            --region=${{ env.REGION }} \
            --image=${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.API_SERVICE_NAME }}-repo/api:latest \
            --task-timeout=300 \
            --memory=512Mi \
            --cpu=1 \
            --command=/usr/local/bin/run-artisan.sh \
            --args=migrate,--force \
            --set-cloudsql-instances=${{ env.CLOUD_SQL_CONNECTION_NAME }} \
            --set-env-vars="APP_ENV=production,DB_CONNECTION=mysql,DB_SOCKET=/cloudsql/${{ env.CLOUD_SQL_CONNECTION_NAME }},DB_PORT=3306,DB_DATABASE=lomis_internal,DB_USERNAME=h1431532403240" \
            --set-secrets="APP_KEY=LARAVEL_APP_KEY:latest,DB_PASSWORD=LARAVEL_DB_PASSWORD:latest" \
            --execute-now || \
          gcloud run jobs execute ${{ env.API_SERVICE_NAME }}-migrate \
            --region=${{ env.REGION }} \
            --wait
        working-directory: . # 此步驟在根目錄執行

      - name: 'Run Initial Admin Seeder'
        run: |-
          gcloud run jobs create ${{ env.API_SERVICE_NAME }}-seed-admin \
            --region=${{ env.REGION }} \
            --image=${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.API_SERVICE_NAME }}-repo/api:latest \
            --task-timeout=300 \
            --memory=512Mi \
            --cpu=1 \
            --command=/usr/local/bin/run-artisan.sh \
            --args=db:seed,--class=InitialAdminSeeder,--force \
            --set-cloudsql-instances=${{ env.CLOUD_SQL_CONNECTION_NAME }} \
            --set-env-vars="APP_ENV=production,DB_CONNECTION=mysql,DB_SOCKET=/cloudsql/${{ env.CLOUD_SQL_CONNECTION_NAME }},DB_PORT=3306,DB_DATABASE=lomis_internal,DB_USERNAME=h1431532403240" \
            --set-secrets="APP_KEY=LARAVEL_APP_KEY:latest,DB_PASSWORD=LARAVEL_DB_PASSWORD:latest" \
            --execute-now || \
          gcloud run jobs execute ${{ env.API_SERVICE_NAME }}-seed-admin \
            --region=${{ env.REGION }} \
            --wait
        working-directory: . # 此步驟在根目錄執行

      # 🔥 關鍵：只有當所有 API 部署步驟都成功後，才處理 OpenAPI
      - name: 'Final OpenAPI Validation Before Cache'
        run: |
          echo "🔍 API 部署完全成功，準備緩存 OpenAPI 規格"
          
          # 🎯 修復路徑問題：檢查正確的 OpenAPI 檔案位置
          OPENAPI_SOURCE="storage/app/scribe/openapi.yaml"
          OPENAPI_TARGET="openapi.yaml"
          
          if [ ! -f "$OPENAPI_SOURCE" ] || [ ! -s "$OPENAPI_SOURCE" ]; then
            echo "❌ OpenAPI 源檔案不存在或為空: $OPENAPI_SOURCE"
            echo "🔍 檢查 storage/app/scribe/ 目錄內容："
            ls -la storage/app/scribe/ || echo "目錄不存在"
            exit 1
          fi
          
          # 複製到根目錄以便 cache（保持 artifact 和 cache 的一致性）
          cp "$OPENAPI_SOURCE" "$OPENAPI_TARGET"
          echo "✅ 已複製 OpenAPI 檔案：$OPENAPI_SOURCE → $OPENAPI_TARGET"
          
          if ! grep -q "openapi:" "$OPENAPI_TARGET"; then
            echo "❌ OpenAPI 檔案格式無效，跳過 cache"
            echo "🔍 檔案內容預覽："
            head -10 "$OPENAPI_TARGET"
            exit 1
          fi
          
          ENDPOINTS=$(grep -c "operationId:" "$OPENAPI_TARGET" || echo "0")
          FINAL_SIZE=$(wc -c < "$OPENAPI_TARGET")
          FINAL_LINES=$(wc -l < "$OPENAPI_TARGET")
          
          echo "📊 OpenAPI 檔案驗證："
          echo "   檔案大小: $FINAL_SIZE bytes"
          echo "   檔案行數: $FINAL_LINES lines"
          echo "   API 端點數量: $ENDPOINTS"
          
          if [ "$ENDPOINTS" -lt 5 ]; then
            echo "⚠️ OpenAPI 端點數量過少 ($ENDPOINTS)，可能有問題"
            echo "🔍 檔案內容預覽："
            head -20 "$OPENAPI_TARGET"
          fi
          
          echo "✅ OpenAPI 檔案驗證通過，準備上傳和緩存"
        working-directory: ./inventory-api
        if: success()

      - name: 'Upload OpenAPI as Artifact'
        uses: actions/upload-artifact@v4
        with:
          name: openapi-spec
          path: inventory-api/openapi.yaml
        if: success()

      - name: 'Cache OpenAPI for Frontend (Final Step)'
        uses: actions/cache@v4
        with:
          path: inventory-api/openapi.yaml
          key: openapi-latest
        if: success()

      - name: 'Confirm OpenAPI Cache Success'
        run: |
          echo "✅ 後端部署完全成功"
          echo "📦 OpenAPI 規格已緩存，對應成功部署的後端版本"
          echo "🎯 前端部署時將使用此規格"
          echo "🔑 Cache Key: openapi-latest"
        if: success()

  deploy-client:
    name: 'Deploy Client to Cloud Run'
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy-api]
    # 🔐 Client 依賴檢測 + API 依賴檢查
    if: |
      always() && 
      needs.detect-changes.outputs.client-needs-deploy == 'true' &&
      (needs.deploy-api.result == 'success' || needs.deploy-api.result == 'skipped')

    permissions:
      contents: 'read'
      id-token: 'write'

    defaults:
      run:
        working-directory: ./inventory-client

    steps:
      - name: 'Deployment Reason Analysis'
        run: |
          echo "🔍 前端部署原因分析："
          
          # 安全地處理 GitHub Actions 輸出變數
          API_CHANGED="${{ needs.detect-changes.outputs.api-changed || 'false' }}"
          CLIENT_CHANGED="${{ needs.detect-changes.outputs.client-changed || 'false' }}"
          DEPLOY_TARGET="${{ needs.detect-changes.outputs.deploy-target || 'auto' }}"
          
          echo "   變數狀態檢查："
          echo "     API_CHANGED: '${API_CHANGED}'"
          echo "     CLIENT_CHANGED: '${CLIENT_CHANGED}'" 
          echo "     DEPLOY_TARGET: '${DEPLOY_TARGET}'"
          echo ""
          
          # 標準化變數值，避免空值問題
          [ -z "$API_CHANGED" ] && API_CHANGED="false"
          [ -z "$CLIENT_CHANGED" ] && CLIENT_CHANGED="false" 
          [ -z "$DEPLOY_TARGET" ] && DEPLOY_TARGET="auto"
          
          echo "   標準化後："
          echo "     API_CHANGED: '${API_CHANGED}'"
          echo "     CLIENT_CHANGED: '${CLIENT_CHANGED}'"
          echo "     DEPLOY_TARGET: '${DEPLOY_TARGET}'"
          echo ""
          
          if [ "${DEPLOY_TARGET}" = "both" ] || [ "${DEPLOY_TARGET}" = "client" ]; then
            echo "   📋 手動指定部署目標: ${DEPLOY_TARGET}"
          elif [ "${API_CHANGED}" = "true" ] && [ "${CLIENT_CHANGED}" = "false" ]; then
            echo "   🔗 API 變更依賴部署 - 同步最新 openapi.yaml"
            echo "   📦 API 有變更，前端需要更新類型定義"
          elif [ "${API_CHANGED}" = "false" ] && [ "${CLIENT_CHANGED}" = "true" ]; then
            echo "   🎯 前端直接變更部署"
            echo "   📦 前端代碼有變更"
          elif [ "${API_CHANGED}" = "true" ] && [ "${CLIENT_CHANGED}" = "true" ]; then
            echo "   🔄 API 和前端都有變更"
            echo "   📦 全面同步部署"
          else
            echo "   ❓ 未預期的部署狀況"
            echo "   這可能是 auto 模式的智能檢測結果"
            echo "   詳細: API=${API_CHANGED}, CLIENT=${CLIENT_CHANGED}, TARGET=${DEPLOY_TARGET}"
          fi
          echo ""
        working-directory: . # 🔧 在根目錄執行，因為此時 inventory-client 目錄還不存在

      - name: 'Checkout'
        uses: actions/checkout@v4

      - name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}
          token_format: 'access_token'

      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v2'

      - name: 'Restore Latest OpenAPI from Cache'
        uses: actions/cache@v4
        with:
          path: inventory-api/openapi.yaml
          key: openapi-latest
        continue-on-error: true

      - name: 'Download OpenAPI Artifact'
        uses: actions/download-artifact@v4
        with:
          name: openapi-spec
          path: ./artifact-temp
        continue-on-error: true

      - name: 'Smart OpenAPI Acquisition Strategy'
        run: |
          # 安全地處理 GitHub Actions 輸出變數
          API_CHANGED="${{ needs.detect-changes.outputs.api-changed || 'false' }}"
          CLIENT_CHANGED="${{ needs.detect-changes.outputs.client-changed || 'false' }}"
          DEPLOY_API_RESULT="${{ needs.deploy-api.result || 'skipped' }}"
          DEPLOY_TARGET="${{ needs.detect-changes.outputs.deploy-target || 'auto' }}"
          
          # 標準化變數值
          [ -z "$API_CHANGED" ] && API_CHANGED="false"
          [ -z "$CLIENT_CHANGED" ] && CLIENT_CHANGED="false"
          [ -z "$DEPLOY_API_RESULT" ] && DEPLOY_API_RESULT="skipped"
          [ -z "$DEPLOY_TARGET" ] && DEPLOY_TARGET="auto"
          
          echo "🔍 智能 OpenAPI 獲取策略（Cache 優先）："
          echo "   API 變更: $API_CHANGED"
          echo "   Client 變更: $CLIENT_CHANGED"
          echo "   API 部署結果: $DEPLOY_API_RESULT"
          echo "   部署目標: $DEPLOY_TARGET"
          echo ""
          
          # 🎯 策略 1: 檢查 cache 結果（最高優先級）
          if [ -f ../inventory-api/openapi.yaml ] && [ -s ../inventory-api/openapi.yaml ] && grep -q "openapi:" ../inventory-api/openapi.yaml; then
            echo "✅ 策略 1 成功：使用 Cache 中的 OpenAPI 規格"
            OPENAPI_SIZE=$(wc -c < ../inventory-api/openapi.yaml)
            OPENAPI_LINES=$(wc -l < ../inventory-api/openapi.yaml)
            echo "   檔案大小: $OPENAPI_SIZE bytes, 行數: $OPENAPI_LINES"
            echo "📦 來源：最後一次成功 API 部署的規格（Cache）"
            
            # 複製到當前工作目錄
            cp ../inventory-api/openapi.yaml ./openapi.yaml
          else
            echo "❌ 策略 1 失敗：Cache 中無可用 OpenAPI 規格"
            
            # 🎯 策略 2: 檢查 artifact 下載結果
            if [ -f ../artifact-temp/openapi.yaml ] && [ -s ../artifact-temp/openapi.yaml ] && grep -q "openapi:" ../artifact-temp/openapi.yaml; then
              echo "✅ 策略 2 成功：使用 Artifact 中的 OpenAPI 規格"
              OPENAPI_SIZE=$(wc -c < ../artifact-temp/openapi.yaml)
              OPENAPI_LINES=$(wc -l < ../artifact-temp/openapi.yaml)
              echo "   檔案大小: $OPENAPI_SIZE bytes, 行數: $OPENAPI_LINES"
              
              # 複製到當前工作目錄
              cp ../artifact-temp/openapi.yaml ./openapi.yaml
              
              if [ "$API_CHANGED" = "true" ]; then
                echo "🔄 來源：最新生成的 API 規格（API 有變更）"
              else
                echo "📋 來源：當次部署生成的 API 規格"
              fi
            else
              echo "❌ 策略 2 失敗：artifact 不可用或內容無效"
              
              # 檢查 artifact 目錄內容以便調試
              echo "🔍 檢查 artifact 目錄內容："
              ls -la ../artifact-temp/ || echo "artifact-temp 目錄不存在"
              
              rm -f ./openapi.yaml
              
              # 🔧 策略 3: 創建增強版 fallback （最後手段）
              echo ""
              echo "🔧 策略 3：創建增強版 fallback OpenAPI 規格"
              echo "   ⚠️ 這是最後手段，可能導致前端類型定義不完整"
              
              cat > ./openapi.yaml << 'EOF'
          openapi: 3.0.0
          info:
            title: Inventory Management API
            version: 1.0.0
            description: 'Enhanced fallback API specification for client build'
            contact:
              name: Inventory System
          servers:
            - url: '${{ secrets.API_CUSTOM_DOMAIN_URL }}'
              description: Production API server
          paths:
            /api/health:
              get:
                summary: Health check endpoint
                operationId: healthCheck
                tags: [System]
                responses:
                  '200':
                    description: API is healthy
                    content:
                      application/json:
                        schema:
                          type: object
                          properties:
                            status:
                              type: string
                              example: ok
            /api/login:
              post:
                summary: User login
                operationId: login
                tags: [Authentication]
                requestBody:
                  required: true
                  content:
                    application/json:
                      schema:
                        type: object
                        properties:
                          username:
                            type: string
                          password:
                            type: string
                responses:
                  '200':
                    description: Login successful
                    content:
                      application/json:
                        schema:
                          type: object
                          properties:
                            user:
                              $ref: '#/components/schemas/User'
                            token:
                              type: string
                  '401':
                    description: Invalid credentials
                    content:
                      application/json:
                        schema:
                          $ref: '#/components/schemas/Error'
            /api/user:
              get:
                summary: Get current user
                operationId: getCurrentUser
                tags: [User]
                security:
                  - bearerAuth: []
                responses:
                  '200':
                    description: Current user information
                    content:
                      application/json:
                        schema:
                          $ref: '#/components/schemas/User'
          components:
            securitySchemes:
              bearerAuth:
                type: http
                scheme: bearer
                bearerFormat: JWT
            schemas:
              User:
                type: object
                properties:
                  id:
                    type: integer
                  name:
                    type: string
                  username:
                    type: string
                  email:
                    type: string
                    format: email
                  is_admin:
                    type: boolean
                  roles:
                    type: array
                    items:
                      type: string
                  roles_display:
                    type: array
                    items:
                      type: string
              Error:
                type: object
                properties:
                  message:
                    type: string
                  code:
                    type: integer
                  errors:
                    type: object
              PaginatedResponse:
                type: object
                properties:
                  data:
                    type: array
                    items: {}
                  meta:
                    type: object
                    properties:
                      current_page:
                        type: integer
                      last_page:
                        type: integer
                      per_page:
                        type: integer
                      total:
                        type: integer
          EOF
            
              echo "📄 已創建增強版 fallback OpenAPI 規格"
              echo "   包含：認證端點、用戶管理、基本資料結構"
              echo "   ⚠️ 仍建議在下次部署時同時更新 API 以獲取完整規格"
            fi
          fi
          
          # 最終檔案狀態報告
          echo ""
          echo "📋 最終 OpenAPI 檔案狀態："
          if [ -f ./openapi.yaml ]; then
            ls -la ./openapi.yaml
            FINAL_SIZE=$(wc -c < ./openapi.yaml)
            FINAL_LINES=$(wc -l < ./openapi.yaml)
          else
            echo "❌ 找不到 OpenAPI 檔案"
            exit 1
          fi
          
          echo "檔案大小: $FINAL_SIZE bytes"
          echo "檔案行數: $FINAL_LINES lines"
          
          # 品質檢查
          ENDPOINTS=$(grep -c "operationId:" ./openapi.yaml || echo "0")
          SCHEMAS=$(grep -c "schemas:" ./openapi.yaml || echo "0")
          echo "API 端點數量: $ENDPOINTS"
          echo "Schema 定義: $SCHEMAS 個區塊"
          
          if [ "$ENDPOINTS" -gt 10 ]; then
            echo "✅ OpenAPI 規格完整度：優秀 ($ENDPOINTS 個端點)"
          elif [ "$ENDPOINTS" -gt 5 ]; then
            echo "✅ OpenAPI 規格完整度：良好 ($ENDPOINTS 個端點)"
          elif [ "$ENDPOINTS" -gt 0 ]; then
            echo "⚠️ OpenAPI 規格完整度：基本 ($ENDPOINTS 個端點，可能影響類型生成)"
          else
            echo "❌ OpenAPI 規格完整度：不足，前端編譯可能失敗"
            exit 1
          fi

      # 🚀 Node.js 緩存優化
      - name: 'Setup Node.js'
        uses: actions/setup-node@v4
        with:
          node-version: '20'  # 更新到更穩定的版本
          cache: 'npm'
          cache-dependency-path: inventory-client/package-lock.json

      - name: 'Install Dependencies'
        run: |
          echo "🔍 安裝依賴前的環境檢查："
          echo "Node.js 版本: $(node --version)"
          echo "npm 版本: $(npm --version)"
          echo "當前目錄: $(pwd)"
          echo "package.json 檢查："
          ls -la package.json
          
          npm ci --verbose
          
          echo "✅ 依賴安裝完成"
          echo "node_modules 大小: $(du -sh node_modules)"
        working-directory: ./inventory-client

      - name: 'Generate API Types'
        run: |
          echo "🔍 生成 API 類型定義："
          echo "OpenAPI 檔案檢查："
          ls -la openapi.yaml
          
          # 確保 openapi.yaml 檔案存在並有效
          if ! grep -q "openapi:" openapi.yaml; then
            echo "❌ OpenAPI 檔案格式無效"
            head -10 openapi.yaml
            exit 1
          fi
          
          npm run api:types
          
          echo "✅ API 類型定義生成完成"
          echo "生成的類型檔案檢查："
          ls -la src/types/api.ts
        working-directory: ./inventory-client
        
      - name: 'Build Application with Enhanced Logging'
        run: |
          echo "🚀 開始構建應用："
          echo "構建前環境檢查："
          echo "記憶體使用: $(free -h || echo 'N/A')"
          echo "磁碟空間: $(df -h . || echo 'N/A')"
          
          # 設置更詳細的 Next.js 構建日誌
          export DEBUG=1
          export NODE_OPTIONS="--max-old-space-size=4096"
          
          npm run build
        working-directory: ./inventory-client

      # 🚀 Docker 構建優化 - 使用多層緩存
      - name: 'Set up Docker Buildx'
        uses: docker/setup-buildx-action@v3

      - name: 'Create Artifact Repository (if not exists)'
        run: |
          gcloud artifacts repositories create ${{ env.CLIENT_SERVICE_NAME }}-repo \
            --repository-format=docker \
            --location=${{ env.REGION }} \
            --description="Client Docker repository" || echo "✅ Repo already exists"
        working-directory: ..

      - name: 'Configure Docker for Artifact Registry'
        run: gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev

      - name: 'Build and Push Client Docker Image (Optimized)'
        uses: docker/build-push-action@v5
        with:
          context: ./inventory-client
          push: true
          tags: ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.CLIENT_SERVICE_NAME }}-repo/client:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
          build-args: |
            NEXT_PUBLIC_API_BASE_URL=${{ secrets.API_CUSTOM_DOMAIN_URL }}

      - name: 'Deploy Client to Cloud Run (固定域名版本)'
        id: deploy_client
        run: |-
          gcloud run deploy ${{ env.CLIENT_SERVICE_NAME }} \
            --image=${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.CLIENT_SERVICE_NAME }}-repo/client:latest \
            --region=${{ env.REGION }} \
            --platform=managed \
            --allow-unauthenticated \
            --set-env-vars="NEXT_PUBLIC_API_BASE_URL=${{ secrets.API_CUSTOM_DOMAIN_URL }},NEXTAUTH_URL=${{ secrets.CLIENT_CUSTOM_DOMAIN_URL }},AUTH_URL=${{ secrets.CLIENT_CUSTOM_DOMAIN_URL }},AUTH_TRUST_HOST=auto" \
            --set-secrets="NEXTAUTH_SECRET=NEXTAUTH_SECRET:latest" \
            --timeout=300 \
            --memory=512Mi \
            --cpu=1 \
            --concurrency=100 \
            --min-instances=0 \
            --max-instances=3
        working-directory: . # 此步驟在根目錄執行

      # 註解：動態域名部分（保留以備將來使用）
      # - name: 'Determine API URL (動態版本 - 已停用)'
      #   id: get_api_url
      #   run: |-
      #     # 優先使用自訂網域（如果有設定）
      #     if [ ! -z "${{ secrets.API_CUSTOM_DOMAIN_URL }}" ]; then
      #       echo "API_URL=${{ secrets.API_CUSTOM_DOMAIN_URL }}" >> $GITHUB_OUTPUT
      #       echo "使用自訂網域: ${{ secrets.API_CUSTOM_DOMAIN_URL }}"
      #     else
      #       # 獲取實際部署的 API URL
      #       API_URL=$(gcloud run services describe ${{ env.API_SERVICE_NAME }} --platform=managed --region=${{ env.REGION }} --format='value(status.url)')
      #       echo "API_URL=$API_URL" >> $GITHUB_OUTPUT
      #       echo "使用 Cloud Run URL: $API_URL"
      #     fi
      #   working-directory: . # 此步驟在根目錄執行

      - name: 'Display Deployment URLs'
        run: |-
          echo "🎉 部署完成！"
          echo ""
          echo "📋 本次部署總結："
          
          # 安全地處理變數
          API_CHANGED="${{ needs.detect-changes.outputs.api-changed || 'false' }}"
          CLIENT_CHANGED="${{ needs.detect-changes.outputs.client-changed || 'false' }}"
          [ -z "$API_CHANGED" ] && API_CHANGED="false"
          [ -z "$CLIENT_CHANGED" ] && CLIENT_CHANGED="false"
          
          if [ "${API_CHANGED}" = "true" ] && [ "${CLIENT_CHANGED}" = "false" ]; then
            echo "   🔗 API 變更觸發的依賴部署"
            echo "   📦 API 有更新 → 前端同步新的 API 類型定義"
          elif [ "${API_CHANGED}" = "false" ] && [ "${CLIENT_CHANGED}" = "true" ]; then
            echo "   🎯 前端獨立部署"
            echo "   📦 只有前端代碼變更"
          elif [ "${API_CHANGED}" = "true" ] && [ "${CLIENT_CHANGED}" = "true" ]; then
            echo "   🔄 前後端全面更新"
            echo "   📦 API 和前端都有變更"
          fi
          
          echo ""
          echo "🌐 服務網址："
          echo "   API 服務: ${{ secrets.API_CUSTOM_DOMAIN_URL }}"
          echo "   前端服務: ${{ secrets.CLIENT_CUSTOM_DOMAIN_URL }}"
          echo ""
          echo "💡 依賴邏輯說明："
          echo "   • API 變更 → 前端自動同步 (openapi.yaml 依賴)"
          echo "   • 前端變更 → 前端獨立部署"
          echo "   • 無變更 → 跳過部署（節省時間）"
        working-directory: . # 此步驟在根目錄執行

  # 🎯 部署總結
  deployment-summary:
    name: 'Deployment Summary'
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy-api, deploy-client]
    if: always() && github.repository == 'lomismoney/Mir01'
    
    steps:
      - name: 'Complete Deployment Summary'
        run: |
          echo "🏁 完整部署總結報告"
          echo "======================"
          echo ""
          
          # 安全地取得所有相關變數
          API_CHANGED="${{ needs.detect-changes.outputs.api-changed || 'false' }}"
          CLIENT_CHANGED="${{ needs.detect-changes.outputs.client-changed || 'false' }}"
          CLIENT_NEEDS_DEPLOY="${{ needs.detect-changes.outputs.client-needs-deploy || 'false' }}"
          FORCE_DEPLOY="${{ needs.detect-changes.outputs.force-deploy || 'false' }}"
          DEPLOY_TARGET="${{ needs.detect-changes.outputs.deploy-target || 'auto' }}"
          
          DETECT_RESULT="${{ needs.detect-changes.result || 'skipped' }}"
          API_RESULT="${{ needs.deploy-api.result || 'skipped' }}"
          CLIENT_RESULT="${{ needs.deploy-client.result || 'skipped' }}"
          
          # 標準化變數值
          [ -z "$API_CHANGED" ] && API_CHANGED="false"
          [ -z "$CLIENT_CHANGED" ] && CLIENT_CHANGED="false"
          [ -z "$CLIENT_NEEDS_DEPLOY" ] && CLIENT_NEEDS_DEPLOY="false"
          [ -z "$FORCE_DEPLOY" ] && FORCE_DEPLOY="false"
          [ -z "$DEPLOY_TARGET" ] && DEPLOY_TARGET="auto"
          [ -z "$DETECT_RESULT" ] && DETECT_RESULT="skipped"
          [ -z "$API_RESULT" ] && API_RESULT="skipped"
          [ -z "$CLIENT_RESULT" ] && CLIENT_RESULT="skipped"
          
          echo "📊 變更檢測結果："
          echo "   檢測狀態: ${DETECT_RESULT}"
          echo "   API 變更: ${API_CHANGED}"
          echo "   Client 變更: ${CLIENT_CHANGED}"
          echo "   強制部署: ${FORCE_DEPLOY}"
          echo "   部署目標: ${DEPLOY_TARGET}"
          echo ""
          
          echo "🚀 部署執行結果："
          echo "   API 部署: ${API_RESULT}"
          echo "   Client 部署: ${CLIENT_RESULT}"
          echo ""
          
          # 分析部署狀況
          if [ "${DETECT_RESULT}" != "success" ]; then
            echo "❌ 變更檢測失敗 - 部署流程異常終止"
            echo "   請檢查倉庫權限或變更檢測邏輯"
            exit 1
          fi
          
          # 總結部署原因和結果
          echo "📋 本次部署分析："
          
          if [ "${FORCE_DEPLOY}" = "true" ]; then
            echo "   🔄 強制部署模式"
            echo "   原因: 手動觸發強制部署"
          elif [ "${DEPLOY_TARGET}" = "api" ] || [ "${DEPLOY_TARGET}" = "client" ] || [ "${DEPLOY_TARGET}" = "both" ]; then
            echo "   🎯 手動指定部署"
            echo "   目標: ${DEPLOY_TARGET}"
          elif [ "${DEPLOY_TARGET}" = "auto" ] && [ "${API_CHANGED}" = "true" ] && [ "${CLIENT_CHANGED}" = "false" ]; then
            echo "   🔗 API 變更觸發連鎖部署"
            echo "   原因: API 變更 → Client 同步 openapi.yaml"
          elif [ "${DEPLOY_TARGET}" = "auto" ] && [ "${API_CHANGED}" = "false" ] && [ "${CLIENT_CHANGED}" = "true" ]; then
            echo "   🎯 前端獨立部署"
            echo "   原因: 只有前端代碼變更"
          elif [ "${DEPLOY_TARGET}" = "auto" ] && [ "${API_CHANGED}" = "true" ] && [ "${CLIENT_CHANGED}" = "true" ]; then
            echo "   🔄 全面更新部署"
            echo "   原因: API 和前端都有變更"
          elif [ "${DEPLOY_TARGET}" = "auto" ] && [ "${API_CHANGED}" = "false" ] && [ "${CLIENT_CHANGED}" = "false" ]; then
            echo "   ✅ 無變更，跳過部署"
            echo "   原因: 沒有檢測到相關檔案變更"
          else
            echo "   ❓ 未知部署模式"
            echo "   DEPLOY_TARGET: ${DEPLOY_TARGET}, API: ${API_CHANGED}, CLIENT: ${CLIENT_CHANGED}"
          fi
          
          echo ""
          
          # 檢查部署成功狀況
          SUCCESS_COUNT=0
          SKIP_COUNT=0
          FAIL_COUNT=0
          
          if [ "${API_RESULT}" = "success" ]; then
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            echo "✅ API 部署成功"
          elif [ "${API_RESULT}" = "skipped" ]; then
            SKIP_COUNT=$((SKIP_COUNT + 1))
            echo "⏭️ API 部署跳過（無需更新）"
          elif [ "${API_RESULT}" = "failure" ]; then
            FAIL_COUNT=$((FAIL_COUNT + 1))
            echo "❌ API 部署失敗"
          fi
          
          if [ "${CLIENT_RESULT}" = "success" ]; then
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            echo "✅ 前端部署成功"
          elif [ "${CLIENT_RESULT}" = "skipped" ]; then
            SKIP_COUNT=$((SKIP_COUNT + 1))
            echo "⏭️ 前端部署跳過（無需更新或依賴失敗）"
          elif [ "${CLIENT_RESULT}" = "failure" ]; then
            FAIL_COUNT=$((FAIL_COUNT + 1))
            echo "❌ 前端部署失敗"
          fi
          
          echo ""
          echo "📈 部署統計："
          echo "   成功: ${SUCCESS_COUNT} 項"
          echo "   跳過: ${SKIP_COUNT} 項"
          echo "   失敗: ${FAIL_COUNT} 項"
          
          if [ ${FAIL_COUNT} -gt 0 ]; then
            echo ""
            echo "🚨 部署警告："
            echo "   有 ${FAIL_COUNT} 項部署失敗，請檢查上述日誌"
            if [ "${API_RESULT}" = "failure" ] && [ "${CLIENT_RESULT}" = "skipped" ]; then
              echo "   💡 前端可能因為 API 部署失敗而被跳過"
            fi
          elif [ ${SUCCESS_COUNT} -gt 0 ]; then
            echo ""
            echo "🎉 部署成功完成！"
            echo ""
            echo "🌐 服務網址："
            echo "   API: ${{ secrets.API_CUSTOM_DOMAIN_URL }}"
            echo "   前端: ${{ secrets.CLIENT_CUSTOM_DOMAIN_URL }}"
          else
            echo ""
            echo "✅ 無需部署，系統保持最新狀態"
            echo "   節省部署時間和資源"
          fi
          
          echo ""
          echo "⏱️ 部署流程優化："
          echo "   • 智能變更檢測 - 只部署必要服務"
          echo "   • Docker 多層緩存 - 加速構建過程"
          echo "   • OpenAPI 同步 - 確保前後端契約一致"
          echo "   • 依賴邏輯 - API 變更自動觸發前端同步"
          
          # 設置最終退出碼
          if [ ${FAIL_COUNT} -gt 0 ]; then
            echo ""
            echo "❌ 工作流程以失敗狀態結束（有部署失敗）"
            exit 1
          else
            echo ""
            echo "✅ 工作流程成功完成"
            exit 0
          fi
